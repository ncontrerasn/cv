<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Hardware Rendering #  Este proceso consiste en renderizar utilizando el hardware de una GPU (Graphic Processing Unit) en vez de la CPU, lo cual permite una renderización más veloz a comparación de hacerlo con la CPU. Las tarjetas gráficas se crearon precisamente para manejar procesos que son muy intensos gráficamente hablando, lo que da una ventaja grande frente a las CPU.
Como todo, esto tiene sus pros:
 Se puede lograr una gran escalabilidad en una infraestructura con varias tarjetas gráficas a disposición.">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content>
<meta property="og:description" content="Hardware Rendering #  Este proceso consiste en renderizar utilizando el hardware de una GPU (Graphic Processing Unit) en vez de la CPU, lo cual permite una renderización más veloz a comparación de hacerlo con la CPU. Las tarjetas gráficas se crearon precisamente para manejar procesos que son muy intensos gráficamente hablando, lo que da una ventaja grande frente a las CPU.
Como todo, esto tiene sus pros:
 Se puede lograr una gran escalabilidad en una infraestructura con varias tarjetas gráficas a disposición.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ncontrerasn.github.io/cv/docs/fotoMosaico/hardware/"><meta property="article:section" content="docs">
<meta property="article:modified_time" content="2022-02-06T23:14:25-05:00">
<title>Hardware | Visual Computing</title>
<link rel=manifest href=/cv/manifest.json>
<link rel=icon href=/cv/favicon.png type=image/x-icon>
<link rel=stylesheet href=/cv/book.min.89a77f7e702a8626749b948bbfb01109823daf6c1246ca407d1378833494c402.css integrity="sha256-iad/fnAqhiZ0m5SLv7ARCYI9r2wSRspAfRN4gzSUxAI=" crossorigin=anonymous>
<script defer src=/cv/flexsearch.min.js></script>
<script defer src=/cv/en.search.min.f1c0eec4cd571625c447bbc0b0ab25de2caf6bc2d560a9c2c5f48ff062ba884e.js integrity="sha256-8cDuxM1XFiXER7vAsKsl3iyva8LVYKnCxfSP8GK6iE4=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/cv/><span>Visual Computing</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li>
<input type=checkbox id=section-455c172e5d869d2bd71a5e8d3919cbfb class=toggle>
<label for=section-455c172e5d869d2bd71a5e8d3919cbfb class="flex justify-between">
<a role=button>Equipo</a>
</label>
<ul>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/equipo/esgonzalezca/>Esgonzalezca</a>
</li>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/equipo/jreinza/>Jreinza</a>
</li>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/equipo/ncontrerasn/>Ncontrerasn</a>
</li>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/equipo/semorenore/>Semorenore</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-6cccca1caac4709c4546586248d1dc66 class=toggle checked>
<label for=section-6cccca1caac4709c4546586248d1dc66 class="flex justify-between">
<a role=button>Foto Mosaico</a>
</label>
<ul>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/fotoMosaico/hardware/ class=active>Hardware</a>
</li>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/fotoMosaico/software/>Software</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-341a116ad5c8e4c380cc77b7fab02191 class=toggle>
<label for=section-341a116ad5c8e4c380cc77b7fab02191 class="flex justify-between">
<a role=button>Rendering</a>
</label>
<ul>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/rendering/algoritmo_rasterizaci%C3%B3n/>Algoritmo Rasterización</a>
</li>
<li>
<a href=https://ncontrerasn.github.io/cv/docs/rendering/algoritmo_visibilidad/>Algoritmo Visibilidad</a>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<a href=/cv/posts/>
Blog
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/cv/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Hardware</strong>
<label for=toc-control>
<img src=/cv/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#hardware-rendering><strong>Hardware Rendering</strong></a>
<ul>
<li><a href=#fuentes><strong>Fuentes</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h2 id=hardware-rendering>
<strong>Hardware Rendering</strong>
<a class=anchor href=#hardware-rendering>#</a>
</h2>
<p>Este proceso consiste en renderizar utilizando el hardware de una GPU (Graphic Processing Unit) en vez de la CPU, lo cual permite una renderización más veloz a comparación de hacerlo con la CPU. Las tarjetas gráficas se crearon precisamente para manejar procesos que son muy intensos gráficamente hablando, lo que da una ventaja grande frente a las CPU.</p>
<p>Como todo, esto tiene sus pros:</p>
<ul>
<li>Se puede lograr una gran escalabilidad en una infraestructura con varias tarjetas gráficas a disposición.</li>
<li>La paralelización que se puede lograr a través de este hardware mejora no solo el rendimiento del render si no que permite que la CPU se encargue de otras tareas, mejorando la armonía del sistema.</li>
</ul>
<p>Las partes no tan positivas serían:</p>
<ul>
<li>Las tarjetas gráficas no tienen un acceso directo a la memoria del sistema principal, por lo que tiene que lograr esta comunicación por medio de la CPU.</li>
<li>Es más complicado lograr la compatibilidad de las tarjetas graficas con el render puesto que no solo depende de los fabricantes de estas si no de los controladores que el sistema tenga instalados para interactuar con estas.</li>
</ul>
<div align=center>
<iframe id=ui-mosaic style=width:700px;height:700px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/objetos/p5.quadrille.js/p5.quadrille.min.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.shaderbox/p5.shaderbox.min.js></script> 
            
            
            
            <script src=/cv/sketches/ui-mosaic.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<iframe id="Dynamic Kanizsa Illusion" style=width:800px;height:800px srcdoc='
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              


let theShader;
let video;
let planeSide = 1000;
let button;
let debug;
let slider;
let Grayimgs = new Array(10);

function imgArraySortLuma(imagesArray){
  let lumaMediaArray = [];
  let index = 0;

  imagesArray.forEach(function(image) {
    lumaMediaArray[index] = calculateLuma(image);
    index ++;
  });
  bubbleSort(lumaMediaArray, imagesArray, lumaMediaArray.length);
  return imagesArray;
}

function swap(lumaArray, imagesArray, xp, yp){
    var temp = lumaArray[xp];
    lumaArray[xp] = lumaArray[yp];
    lumaArray[yp] = temp;

    var temp2 = imagesArray[xp];
    imagesArray[xp] = imagesArray[yp];
    imagesArray[yp] = temp2;
}

// An optimized version of Bubble Sort
function bubbleSort(lumaArray, imagesArray, n){
var i, j;
for (i = 0; i < n - 1; i++){
    for (j = 0; j < n - i - 1; j++){
        if (lumaArray[j] < lumaArray[j + 1])
          swap(lumaArray, imagesArray, j, j + 1);
    }
  }
}

function calculateLuma(image){
  var sum = 0;
  image.loadPixels();

  for (let i = 0; i < 4 * (image.width * image.height / 2); i += 4) 
    sum += 0.333 * image.pixels[i] + 0.333 * image.pixels[i+1] + 0.333 * image.pixels[i+2];
  
  return sum / (image.width * image.height);
}

function preload(){
  // load the shader
  theShader = loadShader(&#39;/cv/docs/fotoMosaico/texture.vert&#39;,&#39;/cv/docs/fotoMosaico/texture.frag&#39;);
  video = createVideo("/cv/docs/fotoMosaico/picnic.mp4");
  var k = 0;
  for (let i=0; i<15; i++){
    Grayimgs[k] = loadImage("/cv/docs/fotoMosaico/imgDes/"+(i+1)+".jpg");
    k = k + 1;
  }

  Grayimgs = imgArraySortLuma(Grayimgs);
}

function setup() {
  // shaders require WEBGL mode to work
  createCanvas(1000, 1000, WEBGL);
  textureMode(NORMAL);
  video.loop();
  //video.hide();
  video.volume(0);
  noStroke();
  shader(theShader);
  // here we&#39;re using setUniform() to send our uniform values to the shader
  var str = ""
  for (var i=0 ; i<15 ; i++){
    str = "Gr"+String(15-i);
    theShader.setUniform(str, Grayimgs[i]);
  }
  theShader.setUniform("resolution", 100);
  debug = true;
  theShader.setUniform("debug", debug);

  //Slider Config
  slider = createSlider(10,500,100,10);
  slider.position( 100, 30);
  slider.style(&#39;width&#39;, &#39;200px&#39;);
  showPixel = createElement(&#39;h2&#39;, &#39;px &#39;+100);
  showPixel.position( 30, 0);
}

function draw() {
  theShader.setUniform("image", video);
  theShader.setUniform("resolution", slider.value());
  showPixel.html(&#39;px &#39;+slider.value());
  background(0);
  beginShape();
  vertex(-planeSide/2, -planeSide/2, 0, 0); // esquina inferior izquierda
  vertex(planeSide/2, -planeSide/2, 1, 0); // esquina inferior derecha
  vertex(planeSide/2, planeSide/2, 1, 1); // esquina superior derecha
  vertex(-planeSide/2, planeSide/2, 0, 1); // esquina superior izquierda
  endShape(CLOSE);
}

function keyPressed(){
  if (key === &#39;d&#39;){
    debug = !debug;
    theShader.setUniform("debug", debug);
  }
}


            </script>
          </head>
          <body>
          </body>
        </html>
      '></iframe>
</div>
<div align=center>
<iframe id="Dynamic Kanizsa Illusion" style=width:800px;height:800px srcdoc='
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script>
              


let theShader;
let img;
let planeSide = 1000;
let button;
let debug;
let slider;
let Grayimgs = new Array(10);

function imgArraySortLuma(imagesArray){
  let lumaMediaArray = [];
  let index = 0;

  imagesArray.forEach(function(image) {
    lumaMediaArray[index] = calculateLuma(image);
    index ++;
  });
  console.log(lumaMediaArray);
  bubbleSort(lumaMediaArray, imagesArray, lumaMediaArray.length);
  console.log(lumaMediaArray);
  return imagesArray;
}

function swap(lumaArray, imagesArray, xp, yp){
    var temp = lumaArray[xp];
    lumaArray[xp] = lumaArray[yp];
    lumaArray[yp] = temp;

    var temp2 = imagesArray[xp];
    imagesArray[xp] = imagesArray[yp];
    imagesArray[yp] = temp2;
}

// An optimized version of Bubble Sort
function bubbleSort(lumaArray, imagesArray, n){
var i, j;
for (i = 0; i < n - 1; i++){
    for (j = 0; j < n - i - 1; j++){
        if (lumaArray[j] < lumaArray[j + 1])
          swap(lumaArray, imagesArray, j, j + 1);
    }
  }
}

function calculateLuma(image){
var i = 0, total = 0;
image.loadPixels();

for (let y = 0; y < image.height; y += 1) {
    for (let x = 0; x < image.width; x += 1) {
      pixel = image.pixels[(y * image.width + x)];
      total = total + brightness(pixel);
      i++;
    }
  }
  return total / i;
}

function preload(){
  // load the shader
  theShader = loadShader(&#39;/cv/docs/fotoMosaico/texture.vert&#39;,&#39;/cv/docs/fotoMosaico/texture.frag&#39;);
  img = loadImage("/cv/docs/fotoMosaico/imgHW/londres.jpg");
  var k = 0;
  for(let i = 0; i<15; i++){
    Grayimgs[i]=(loadImage(`https://picsum.photos/50?random=${i+1}`));
  }
 // for (let i=0; i<15; i++){
    
   // Grayimgs[k] = loadImage("/cv/docs/fotoMosaico/imgDes/"+(i+1)+".jpg");
   // k = k + 1;
 // }
  //Grayimgs = imgArraySortLuma(Grayimgs);
}

function setup() {
  // shaders require WEBGL mode to work
  Grayimgs = imgArraySortLuma(Grayimgs);
  createCanvas(1000, 1000, WEBGL);
  textureMode(NORMAL);
  shader(theShader);
  // here we&#39;re using setUniform() to send our uniform values to the shader
  theShader.setUniform("image", img);
  var str = ""
  for (var i=0 ; i<15 ; i++){
    str = "Gr"+String(15-i);
    theShader.setUniform(str, Grayimgs[i]);
  }
  theShader.setUniform("resolution", 100);
  debug = true;
  theShader.setUniform("debug", debug);

  //Slider Config
  slider = createSlider(10,500,100,10);
  slider.position( 100, 30);
  slider.style(&#39;width&#39;, &#39;200px&#39;);
  showPixel = createElement(&#39;h2&#39;, &#39;px &#39;+100);
  showPixel.position( 30, 0);
}

function draw() {
  theShader.setUniform("resolution", slider.value());
  showPixel.html(&#39;px &#39;+slider.value());
  background(0);
  beginShape();
  vertex(-planeSide/2, -planeSide/2, 0, 0); // esquina inferior izquierda
  vertex(planeSide/2, -planeSide/2, 1, 0); // esquina inferior derecha
  vertex(planeSide/2, planeSide/2, 1, 1); // esquina superior derecha
  vertex(-planeSide/2, planeSide/2, 0, 1); // esquina superior izquierda
  endShape(CLOSE);
}

function keyPressed(){
  if (key === &#39;d&#39;){
    debug = !debug;
    theShader.setUniform("debug", debug);
  }
}


            </script>
          </head>
          <body>
          </body>
        </html>
      '></iframe>
</div>
Podemos concluir que el uso de las GPU para render permite una mayor escala en los proyectos a realizar y un mejor rendimiento, sin embargo, su costoinherente y más ahora en el mercado actual demuestra que esta forma de rendering no es muy viable para un proyecto inicial o una apliación sencilla, por lo cual seria más provechos hacer rendering por medio de software.
<h3 id=fuentes>
<strong>Fuentes</strong>
<a class=anchor href=#fuentes>#</a>
</h3>
<ul>
<li><a href=https://develop3d.com/hardware/rendering-hardware/>https://develop3d.com/hardware/rendering-hardware/</a></li>
<li><a href=https://www.omnisci.com/technical-glossary/gpu-rendering>https://www.omnisci.com/technical-glossary/gpu-rendering</a></li>
</ul>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/ncontrerasn/cv/commit/bba57cff816b599c1b476a0729d9fa5c1d835076 title="Last modified by Sergio | February 7, 2022" target=_blank rel=noopener>
<img src=/cv/svg/calendar.svg class=book-icon alt=Calendar>
<span>February 7, 2022</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li>
<ul>
<li><a href=#hardware-rendering><strong>Hardware Rendering</strong></a>
<ul>
<li><a href=#fuentes><strong>Fuentes</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>